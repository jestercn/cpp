#include <bits/stdc++.h>
using namespace std;
/*思路：最终B轨道上各车厢号形成的序列构成一个数组b。
B轨道最初需要的车厢号应该是b[0],下一个需要的是b[1]，以此类推，最后需要的是b[n-1]
C轨道是一个栈结构，定义一个栈来表示存入C轨道的车厢号 
A轨道最前面的车厢aF有两个去向，要么进入B轨道，要么进入C轨道存起来。
如果aF不等于b轨道现在需要的车厢号，那么aF只能存入C轨道
在B轨道需要的车厢更新后，分别看A、C轨道最前面的车厢是否满足
如果A轨道空了，C轨道还有车厢，那么不能得到指定车厢顺序。否则可以。
*/
int stk[1005];//C轨道保存车厢的栈
int p;
int main()
{
    //b保存车厢最终应该形成的顺序，aF表示A轨道中此时排在最前面的车厢号
    int n, b[1005], aF = 1;
    cin>>n;
    for(int i = 0; i < n; ++i)
    {
        cin>>b[i];
    }
    int i = 0;
    while(i < n)
    {
        if(aF == b[i] && aF<=n)//aF<=n表示A轨道还有车厢，若aF>n，说明A轨道的车厢都离开了 
        {
            i++;//看B轨道下一个需求
            aF++;//A轨道的一个车厢到达B轨道
        }
        else if(stk[p] == b[i])//如果C轨道栈顶是B轨道需要的
        {
            p--;//出栈
            i++;//看B轨道下一个需求
        }
        else
        {
        	if(aF<=n)//如果A，C轨道最前面的车厢都不是B轨道需要的，那么将A轨道最前面的车厢进C轨道
            	stk[++p] = aF++;
            else//如果A轨道空了，C轨道的车厢还不能满足B轨道，那么应该输出NO 
            	break; 
        }
    }
    if(i == n)//表示b数组序列的所有数字都被满足了 
        cout<<"YES";
    else
        cout<<"NO";
	return 0;
}
