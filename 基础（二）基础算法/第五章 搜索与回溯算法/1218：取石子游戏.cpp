#include <bits/stdc++.h>
using namespace std;
//证明：假设石子数目为(a,b)且a >= b,如果[a/b] >= 2则先手必胜,如果[a/b]<2,那么先手只有唯一的一种取法。[a/b]表示a除以b取整后的值。 
//以下证明中，a指较大那堆石子的数量，b指较少那堆石子的数量。设[a/b]<2为A情况， [a/b] >= 2为B情况。
//	引理1：A情况时，先手下一次取石子只有一种取法，没有选择。
//	证明：A情况，[a/b] < 2 即 b <= a < 2b，此时只能从a中减少1次b，结果是0 <= a-b < b。若减少2次b，则a-2b < 0，不可能发生。
//  引理2：B情况时，[a/b] >= 2，即a >= 2b，必然有正整数m，使得a-mb < b <= a-(m-1)b < 2b，先手在面对B情况时，可以通过操作来选择下一次是由自己还是由对手来面对(b, a-mb)的情况
//  证明：若想对手面对(b, a-mb)，自己从a中减去m次b即可。若想自己面对(b, a-mb)，则自己从a中减去m-1次b，对手面对(a-(m-1)b, b)，已知b <= a-(m-1)b < 2b，根据引理1，对手只能选择从a-(m-1)b中减去一次b，让先手面对(b, a-mb)
//情况序列：设两人每拿一次石子，记录一次石子的情况。石子情况可以记为由若干个AB组成的序列。
//原始序列：假设遇到B情况的人，都直接在a中取m次b，形成(b, a-mb)，那么针对初始的a,b，经过若干A或B情况，直到其中的一个值为0，结束取石子，这样会形成唯一的AB情况序列，叫做原始序列。
//  引理3:在原始序列中若存在序列：B(若干A)B，先手面对最初的B情况，无论和下一个B中间隔多少个A，先手都能通过一定操作，而后由自己面对下一个B情况
//  证明：若两个B中间A的个数是奇数个，面对第一个B情况时，先手正常操作，在a中减去m个b。若两个B中A的个数是偶数个，那么先手在a中减去m-1个b，形成(a-(m-1)b, b)，相当于人为造出了一个A情况，两个B中A情况的数量还是奇数个，面对下一个B情况的还是先手玩家。 
//  引理4：原始序列最后一个情况一定是B情况。因为最后一个情况中：a是b的整数倍，有a-mb = 0
//定理1：先手面对B情况时必胜
//证明：若一开始[a/b] >= 2，生成的原始序列的首尾都是B情况，中间是由若干个 B(若干A)B 组成的序列段，根据引理3，先手可以通过操作不断让自己面对B情况，直到自己面对最后a是b整数倍的B情况。因此[a/b] >= 2时，先手必胜。 
//当[a/b]<2时，生成的原始序列的第一个情况为A，会形成(若干A)B(若干A)B...B的原始序列。面对若干连续的A情况，先后手都没有操作的空间，只能看谁面对第一个出现的B情况，面对第一个B情况的人即为先手面对B，根据定理1，他可以获胜。 
//所以问题转化为，首先生成原始序列（只需要生成到第一个B情况出现为止），然后看第一个出现的B前面有多少个A，若有偶数个A（包括0个），那么先手赢。若有奇数个A，那么后手赢。 

//解法1：非递归法 看第一个出现的B前面有多少个A，若有偶数个A（包括0），那么先手赢。若有奇数个A，那么后手赢。
//n1, n2：此时两堆石子的石头数字 
//bool isFirstWin(int n1, int n2)
//{
//	int a, b, ctA = 0, temp;//ctA：A情况的数目 
//	if(n1 > n2)//使得a是较大的数，b是较小的数
//	{
//		a = n1;
//		b = n2;
//	}
//	else if(n1 < n2)
//	{
//		a = n2;
//		b = n1;
//	}
//	else
//	{
//		return true;//若二者相等，则先手赢 
//	}
//	while(a < 2 * b)//如果是A情况 
//	{
//		ctA++;
//		temp = b;
//		b = a - b;//在a中减去一次b，得到(b, a - b) 
//		a = temp;
//	}
//	if(ctA % 2 == 0)//看第一个出现的B前面有多少个A，若有偶数个A（包括0），那么先手赢。若有奇数个A，那么后手赢。
//		return true;
//	else
//		return false;
//}

//解法法2，通过尾递归，确定第一次面对B情况的是先手还是后手
//n1, n2：此时两堆石子的石头数字 isFirst:现在面对这一情况的是否是先手 
bool isFirstWin(int n1, int n2, bool isFirst)
{
	int a, b;
	if(n1 > n2)//使得a是较大的数，b是较小的数
	{
		a = n1;
		b = n2;
	}
	else if(n1 < n2)
	{
		a = n2;
		b = n1;
	}
	else
	{
		return true;//若二者相等，则先手赢 
	}
	if(a >= 2 * b)//如果是情况B 
		return isFirst;//此时面对情况B的就是胜者
	else//如果是情况A 
		return isFirstWin(a - b, b, !isFirst);
}
int main()
{   
   	int a, b;
   	while(true)
   	{
   		cin>>a>>b;
   		if(a == 0 && b == 0)
   			break;
   		else
   		{
   			if(isFirstWin(a, b, true))//解法1：isFirstWin(a, b) 解法2：isFirstWin(a, b, true) 
   				cout<<"win"<<endl;
   			else
   				cout<<"lose"<<endl;
		}
	}
    return 0;
}
