#include<bits/stdc++.h>
using namespace std;
/*直接两层循环寻找逆序对的话，时间复杂度是O(n^2)，该题问题规模为10^5，会超时。 
用归并排序解决逆序对问题
例如一次归并排序，两个数组分别为a1，a2，临时数组为t，逆序对数量s:
a1:1 6 8	a2:2 3 7	t:	s:0
第一步：a1的1进入到临时数组t中，1和a2中的数字不产生逆序对 
a1:6 8	a2:2 3 7	t:1		s:0
第二步：a2的2比a1的6小，2进入t中。2和a1中的所有元素都形成逆序对，逆序对数量增加2
a1:6 8	a2:3 7	t:1 2		s:2
第三步：a2的3比a1的6小，3进入t中。3和a1中的所有元素都形成逆序对，逆序对数量增加2
a1:6 8	a2:7	t:1 2 3		s:4
第四步：a1的6比a2的7小，6进入t中。不产生逆序对
a1:8	a2:7	t:1 2 3 6		s:4
第五步：a2的7比a1的8小，7进入t中。产生逆序对1个
a1:8	a2:	t:1 2 3 6 7		s:5
最后把8 填到t中
a1: a2: t:1 2 3 6 7 8 s:5
此次归并一共找到5个逆序对
总结规律，在归并时，a2数组的最小值比a1数组最小值小的时候，逆序对增加的数量为：此时a1数组剩余元素的个数。
其他时刻，逆序对不增加。
根据这一原理编写程序，归并排序的时间复杂度是O(nlogn)，可以解决规模为10^5的问题 
*/ 
int a[100005], t[100005];
long long s;//s保存逆序对个数，逆序对最多可能有O(n^2)个，n规模为10^5，s的值可能达到10^10，超出int范围，要用long long 
void mSort(int l, int r)
{
	if(l >= r)
		return;
	int mid = (l + r)/2;
	mSort(l, mid);
	mSort(mid + 1, r);
	int i_l = l, i_r = mid + 1, i_t = l;//三个数组的下标 
	while(i_l <= mid && i_r <= r)
	{
		if(a[i_l] <= a[i_r])//两数组最小值相等时，应该让第一数组的元素进入临时数组，不计逆序对 
		{
			t[i_t++] = a[i_l++];
		}
		else//第二个数组最小值比第一个数组的小时，第二个数组最小值与第一数组剩余的所有元素都形成逆序对 
		{
			s += mid - i_l + 1;//第一数组从a[i_l]到a[mid]一共有mid - i_l + 1个元素 
			t[i_t++] = a[i_r++];
		}
	}
	while(i_l <= mid)
	{
		t[i_t++] = a[i_l++]; 
	}
	while(i_r <= r)
	{
		t[i_t++] = a[i_r++];
	}
	for(int i = l; i <= r; ++i)
		a[i] = t[i];
}

int main()
{
	int n;
	cin>>n;
	for(int i = 0; i < n; ++i)
		cin>>a[i];
	mSort(0, n-1);
	cout<<s; 
	return 0; 
}
