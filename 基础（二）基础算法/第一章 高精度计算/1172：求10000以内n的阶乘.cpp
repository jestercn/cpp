#include <bits/stdc++.h>
using namespace std;
//问题1：求数字数组的长度 
//n取最大值时 n = 10000， 运算结果：10000! < 10000^10000=10^40000
//已知数字x的位数为m，有10^(m-1) <= x <10^m，即 m <= lgx+1 (lg：以10为底的对数） 
//求数字10000!的位数x，有x <= lg10^40000+1 = 40001
//所以数字数组长度设为40005即可，应该使用全局变量表示。 

//问题2：该问题如果数字数组中每个元素只表示1位数，那么由于运算次数过多，会超时 
//数字数组的进制，即数字数组中一个元素可以表示的数字范围。默认是10进制，一个元素可以表示0~9。如果设为100进制，一个元素就可以表示0~99的数字。
//数字数组的进制增大，可以减少乘法中相乘的次数，提高运算效率。

//由于int型只能有效表示9位数字，乘法算法中有r[i+j-1] = a[i]*b[j] + c + r[i+j-1];这样的语句，也就是说参与运算的a，b元素的位数最多是4位数，才能保证结果r的元素的位数不超过9位数。因而JZ能取到的最大值为10000 
#define JZ 10000//数字数组中的进制 

//高精度乘法 
void Multiply(int a[], int b[], int r[])
{
    for(int i = 1; i <= a[0]; ++i)
    {
        int c = 0;
        for(int j = 1; j <= b[0]; ++j)
        {
            r[i+j-1] = a[i]*b[j] + c + r[i+j-1];
            c = r[i+j-1] / JZ;
            r[i+j-1] %= JZ;
        }
        r[i+b[0]] += c;
    }
    int r_i = a[0] + b[0];//去除多余的0
    while(r[r_i] == 0 && r_i > 1)
        r_i--;
    r[0] = r_i;
}

//数字数组a增加1 
void AddOne(int a[])
{
	int i = 1, c = 1;
	while(c > 0)
	{
		a[i]++;
		c = a[i] / JZ;
		a[i] %= JZ;
		i++;
	}
	if(i-1 > a[0])
		a[0] = i - 1;
}

//将JZ进制的数字数组以十进制的方式输出 
//如：123456789 保存在1000进制的数字数组中，a[0]~a[3]值为：3 789 456 123
//从高位到低位顺序输出数字即可 注意，除了第一个要输出的数字，其他要输出数字时前面补0 
//printf("%0*d",x,y) 在宽度为x的空间中输出数字y，剩余空间在前面补0 
void showNum(int a[])
{
	printf("%d", a[a[0]]);//第一个数字正常输出，不补0 
    for(int i = a[0]-1; i >= 1; --i)
        printf("%0*d", (int)log10(JZ), a[i]);//预设JZ = 10^x，(int)log10(JZ)求x。补0输出  
}

//数字b复制给数字a
void numcpy(int a[], int b[])
{
	int len = b[0];
	for(int i = 0; i <= len; ++i)
	{
		a[i] = b[i];
	}
}

int a[40005], b[40005], r[40005];//a用来保存阶乘结果，b用来保存不断变大的要乘的数字，r用作临时保存空间 
int main()
{
    int n;
    cin>>n;
    //把a构造成1 
    a[0] = 1;
    a[1] = 1;
    for(int i = 1; i <= n; ++i)
    {    	
    	AddOne(b);
    	Multiply(a, b, r);
		numcpy(a, r);//把上一次乘法的结果存入a
		memset(r, 0, sizeof(r));//将r清空 
	}
    showNum(a);
}
